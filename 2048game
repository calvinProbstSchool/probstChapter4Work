# Minesweeper
# By Calvin Probst calvin.probst@gmail.com
# https://github.com/calvinProbstSchool/probstChapter3work
# 32, 4

import random
from typing import Tuple

import pygame
import sys
import math
from pygame.locals import *

FPS = 30
ANIMATIONSPEED = 5
ROWSIZE = 4
NEWNUMBERS = (2, 4)
WINNINGNUMBER = 2048
BOXSIZE = 100
GAPSIZE = 30
TEXTGAP = 100
WINDOWSIZE = GAPSIZE + (GAPSIZE + BOXSIZE) * BOXSIZE + 2 * TEXTGAP
BOARDSIZE = GAPSIZE + (GAPSIZE + BOXSIZE) * BOXSIZE

DIRUP = "UP"
DIRRIGHT = "RIGHT"
DIRDOWN = "DOWN"
DIRLEFT = "LEFT"

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
BRIGHTBLUE = (0, 50, 255)
DARKTURQUOISE = (3, 54, 73)
GREEN = (0, 204, 0)

BGCOLOR = DARKTURQUOISE
BOARDBGCOLOR = BLACK
BOXCOLOR1 = BRIGHTBLUE
BOXCOLOR2: Tuple[int, int, int] = GREEN
TEXTCOLOR = BLACK
SCORETEXT = WHITE

def main():
    global DISPLAYSURF, FPSCLOCK, BOXFONT, SCOREFONT
    pygame.init()
    pygame.mixer_music.load("Alcazar.mp3")
    pygame.mixer_music.play(-1, 0.0)
    FPSCLOCK = pygame.time.Clock()
    DISPLAYSURF = pygame.display.set_mode((WINDOWSIZE, WINDOWSIZE))
    BOXFONT = pygame.font.SysFont("3Dventure.ttf", 60)
    board = []
    for x in range(ROWSIZE):
        row = []
        for y in range(ROWSIZE):
            row.append([0])
        board.append(row)

    score = 0
    highscore = 0

    drawGameBoard(board, score, highscore)

    undoButton = BOXFONT.render("Undo", False, TEXTCOLOR, BOXCOLOR2)
    ngButton = BOXFONT.render("New Game", False, TEXTCOLOR, BOXCOLOR2)

    undoPos = (WINDOWSIZE - (TEXTGAP / 2), (WINDOWSIZE / 2) + 50)
    ngPos = (WINDOWSIZE - (TEXTGAP / 2), (WINDOWSIZE / 2) - 50)

    DISPLAYSURF.blit(undoButton, undoPos)
    DISPLAYSURF.blit(ngButton, ngPos)

    undoRect = undoButton.get_rect()
    undoRect.left, undoRect.top = undoPos
    ngRect = ngButton.get_rect()
    ngRect.left, ngRect.top = ngPos

    playingGame = True
    mousex = 0
    mousey = 0


    while True:
        mouseDown = False
        keyPress = False
        keyDir = ""
        drawGameBoard(board, score, highscore)

        #do the button blit here

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == QUIT or (event.type == KEYUP and event.key == K_ESCAPE):
                pygame.quit()
                sys.exit()
            elif event.type == KEYUP:
                if event.key == K_LEFT:
                    keyPress = True
                    keyDir = DIRLEFT
                elif event.key == K_RIGHT:
                    keyPress = True
                    keyDir = DIRRIGHT
                elif event.key == K_UP:
                    keyPress = True
                    keyDir = DIRUP
                elif event.key == K_DOWN:
                    keyPress = True
                    keyDir = DIRDOWN
            elif event.type == MOUSEMOTION:
                mousex, mousey = event.pos
            elif event.type == MOUSEBUTTONUP:
                mousex, mousey = event.pos
                mouseDown = True

        if mouseDown:



def drawGameBoard(board, score, highscore):
    for x in range(ROWSIZE):
        for y in range(ROWSIZE):
            drawTile(board[x][y], boardToCoord(x), boardToCoord(y))
    BOXFONT.render_to(DISPLAYSURF, (WINDOWSIZE / 3, TEXTGAP / 2), "Score:" + str(score), True, BLACK)
    BOXFONT.render_to(DISPLAYSURF, (WINDOWSIZE * 2 / 3, TEXTGAP / 2), "Highscore: " + str(highscore), True, BLACK)


def drawBoardBase():
    pygame.draw.rect(DISPLAYSURF, BOARDBGCOLOR, ((TEXTGAP, TEXTGAP, BOARDSIZE, BOARDSIZE)))


def drawTile(tile, x, y):
    pygame.draw.rect(DISPLAYSURF, getColorValue(tile), (x, y, BOXSIZE, BOXSIZE))
    BOXFONT.render_to(DISPLAYSURF, ((x + (BOXSIZE / 2)), (y + (BOXSIZE / 2))), str(tile), True, TEXTCOLOR)



def getColorValue(tileValue):
    if tileValue == 0:
        return BOARDBGCOLOR
    else:
        step = math.log(tileValue, 2) - 1
        colorR = BOXCOLOR1[0] + int(step * ((BOXCOLOR2[0] - BOXCOLOR1[0]) / 10 ))
        colorG = BOXCOLOR1[1] + int(step * ((BOXCOLOR2[1] - BOXCOLOR1[1]) / 10 ))
        colorB = BOXCOLOR1[2] + int(step * ((BOXCOLOR2[2] - BOXCOLOR1[2]) / 10))
        colorFinal = (colorR, colorB, colorG)
        return (colorFinal)


def boardToCoord(num):
    return TEXTGAP + GAPSIZE + num * (GAPSIZE + BOXSIZE)


def boardToCenterCoord(num):
    return boardToCoord(num) + BOXSIZE / 2


def coordToBoard(num):
    if num < GAPSIZE + TEXTGAP:
        return -1
    overlap = (num - GAPSIZE - TEXTGAP) % (BOXSIZE + GAPSIZE)
    if overlap > BOXSIZE:
        return -1
    else:
        return (num - overlap - GAPSIZE - TEXTGAP) / (BOXSIZE + GAPSIZE)


def chaChaSlideAnimation(tileVal, startX, startY, moveDir, reverse=False):
    travelDistance = BOXSIZE + GAPSIZE
    stepSizeX = int(travelDistance / ANIMATIONSPEED)
    stepSizeY = int(travelDistance / ANIMATIONSPEED)
    if moveDir == DIRUP:
        stepSizeX = 0
        stepSizeY = -1 * stepSizeY
    elif moveDir == DIRDOWN:
        stepSizeX = 0
    elif moveDir == DIRLEFT:
        stepSizeX = -1 * stepSizeX
        stepSizeY = 0
    elif moveDir == DIRRIGHT:
        stepSizeY = 0
    for step in range(ANIMATIONSPEED):
        if reverse:
            drawTile(tileVal, startX, startY)
        drawTile(tileVal, (startX + (stepSizeX * step)), (startY + (stepSizeY * step)))
        pygame.display.update()
        FPSCLOCK.tick(FPS)
        drawTile(0, (startX + (stepSizeX * step)), (startY + (stepSizeY * step)))




def newTile(board):
    tileProb = random.randint(1, 10)
    if tileProb == 1:
        tileVal = 4
    else:
        tileVal = 2
    placed = False
    while not placed:
        posX = random.randint(0, ROWSIZE - 1)
        posY = random.randint(0, ROWSIZE - 1)
        if board[posX][posY] == 0:
            board[posX][posY] = tileVal
            placed = True
    return board